<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>coherence field monitor | CAI</title>
  <meta name="description" content="A practical coherence field monitor that estimates when a model is stable, drifting, or collapsing under compression. Single 0-1 score, bands, and guardrail thresholds." />
  <link rel="icon" href="assets/favicon.png" />
  <link rel="stylesheet" href="styles.css" />
  <meta property="og:title" content="coherence field monitor | compression-aware intelligence" />
  <meta property="og:description" content="Drop-in coherence field metrics for stability under compression and perturbation. Ship guardrails in a day." />
  <meta property="og:type" content="website" />
  <meta name="twitter:card" content="summary" />

  <!-- structured data -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"WebPage",
    "name":"Coherence Field Monitor",
    "description":"Practical coherence field metrics and a single score to detect stability, drift, and collapse in AI systems.",
    "publisher":{"@type":"Organization","name":"Compression-Aware Intelligence"},
    "inLanguage":"en"
  }
  </script>

  <style>
  /* namespace all page-local styles under #cm to avoid touching the global nav */
  #cm .pill{display:inline-block; padding:.25rem .55rem; border:1px solid var(--ink,#111); border-radius:999px; font-size:.85rem}
  #cm .grid{display:grid; gap:1rem}
  #cm .two{grid-template-columns:repeat(2,minmax(0,1fr))}
  #cm .three{grid-template-columns:repeat(3,minmax(0,1fr))}
  #cm .card{border:1px solid rgba(0,0,0,.08); border-radius:.65rem; padding:1rem}
  #cm .lede{font-size:1.1rem; opacity:.95}
  #cm .muted{opacity:.8}
  #cm .small{font-size:.85rem}
  #cm .table{width:100%; border-collapse:collapse}
  #cm .table th,#cm .table td{border-bottom:1px solid rgba(0,0,0,.08); padding:.5rem .4rem; text-align:left; vertical-align:top}
  #cm pre{background:rgba(0,0,0,.04); padding:.8rem; border-radius:.5rem; overflow:auto}
  #cm code{font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace}
  #cm .cta{display:flex; gap:.6rem; flex-wrap:wrap; margin-top:.6rem}
  #cm .button{display:inline-block; padding:.45rem .75rem; border-radius:.5rem; border:1px solid var(--ink,#111); text-decoration:none}
  #cm .copy-btn{font:inherit; border:1px solid currentColor; background:transparent; padding:.35rem .65rem; border-radius:.5rem; cursor:pointer}
  #cm .ok{color:#116611}
  #cm .warn{color:#8a6a00}
  #cm .err{color:#8b0000}
  @media (max-width: 920px){ #cm .two,#cm .three {grid-template-columns:1fr} }
  </style>
</head>

<body>
<header class="site-header wrap">
  <a class="brand" href="index.html"><span class="logo"></span><span>CAI</span></a>
  <nav class="nav">
    <a href="index.html" data-nav>Home</a>
    <a href="proof.html" data-nav>Proof</a>
    <a href="dataset.html" data-nav>Dataset</a>
    <a href="coherencefield.html" data-nav>The Coherence Field</a>
    <a href="principles.html" data-nav>Principles</a>
    <a href="applications.html" data-nav>Applications</a>
    <a href="contradictions.html" data-nav>Contradictions</a>
    <a href="implementations.html" data-nav>Implementations</a>
    <!-- Public demo link -->
    <a href="https://semantic-stability-lab-clinical-59orjfx58.vercel.app" target="_blank" rel="noopener">Stability Lab</a>
    <a href="glossary.html" data-nav>Glossary</a>
    <a href="faq.html" data-nav>FAQ</a>
    <a href="contact.html" data-nav>Contact</a>
  </nav>
</header>

<main id="cm" class="wrap">
  <h1>coherence field monitor</h1>
  <p class="lede">
    a practical set of signals that estimate when a model is stable, drifting, or collapsing. plug it into any inference loop and gate risky outputs with thresholds you control. built as the operational readout of the coherence field from compression aware intelligence (cai).
  </p>
  <p class="muted small">
    version 0.2.0 · coherence field monitor for compression aware intelligence
  </p>

  <!-- overview -->
  <section class="card" id="overview">
    <h2>overview</h2>
    <p><strong>what it is</strong>: a small metrics bundle, thresholds, and alerts that estimate stability under compression and perturbation.</p>

    <p class="muted">
      under cai, each bounded system sits in a <strong>coherence field</strong>: how tightly its outputs hold together when compressed, paraphrased, or given small shocks. this monitor is a practical readout of that field. it does not measure truth. it measures how stable the system is being.
    </p>

    <div class="grid two">
      <div class="card">
        <h3>what it reads</h3>
        <ul>
          <li>consistency across semantically equivalent prompts under compression</li>
          <li>token rhythm under tiny compressed input changes</li>
          <li>agreement across agents or temperature seeds</li>
          <li>waste heat signals like tokens per second vs compression gain</li>
        </ul>
      </div>
      <div class="card">
        <h3>what you get</h3>
        <ul>
          <li>a single <strong>coherence field score</strong> (0-1)</li>
          <li>bands, red line thresholds, and default actions</li>
          <li>a tiny monitor you can ship in a day</li>
        </ul>
        <div class="cta">
          <a class="button" href="implementations.html">integration guides</a>
          <a class="button" href="applications.html">apply in practice</a>
        </div>
      </div>
    </div>

    <p class="muted small">
      scope: this monitors bounded ai systems under their current training and deployment constraints. it does not estimate real world risk, intent, or truthfulness by itself. it is an engineering control layer you pair with task level evals and domain checks.
    </p>
  </section>

  <!-- quick start -->
  <section class="card" id="quickstart">
    <h2>quick start</h2>
    <ol>
      <li>install and import</li>
      <li>wrap your inference call</li>
      <li>set thresholds and actions</li>
    </ol>
<pre id="qs" aria-label="python quick start"><code># 1) install
# pip install cai-coherence-monitor  # placeholder name, or copy the local module into your repo

# 2) import and wrap
from coherence_monitor import Monitor, default_thresholds
mon = Monitor(model, thresholds=default_thresholds())

# 3) call in your loop
result = mon.run(prompt)
print(result.score, result.alerts)

# 4) act on alerts
if "low_rhythm_stability" in result.alerts:
    route_to_slow_path()
</code></pre>
    <button class="copy-btn" data-copy="#qs">copy</button>
  </section>

  <!-- metrics -->
  <section class="card" id="metrics">
    <h2>metrics</h2>
    <p>
      each metric is a surface readout of compression strain in the system: how much the coherence field bends before it snaps.
    </p>

    <table class="table">
      <thead>
        <tr><th>name</th><th>what it reads</th><th>how</th><th>why it matters</th></tr>
      </thead>
      <tbody>
        <tr>
          <td><strong>prompt consistency</strong></td>
          <td>stability across compressed paraphrases</td>
          <td>n paraphrases → embed → pairwise similarity</td>
          <td>low values signal brittle reasoning under small compression changes</td>
        </tr>
        <tr>
          <td><strong>rhythm stability</strong></td>
          <td>token cadence under tiny compressed perturbations</td>
          <td>diff small edits → track per token logprob variance</td>
          <td>spikes often precede off target drifts and local field buckling</td>
        </tr>
        <tr>
          <td><strong>ensemble agreement</strong></td>
          <td>convergence across agents, seeds, or paths</td>
          <td>k runs → n gram or embedding majority</td>
          <td>disagreement flags under specified instructions or competing local minima</td>
        </tr>
        <tr>
          <td><strong>waste heat ratio</strong></td>
          <td>effort vs compression gain</td>
          <td>tokens per second divided by novelty or compression gain</td>
          <td>high ratios suggest the system is burning compute without resolving compression strain</td>
        </tr>
      </tbody>
    </table>

<pre id="schema" aria-label="json schema"><code>{
  "score": 0.78,
  "components": {
    "consistency": 0.88,
    "rhythm": 0.74,
    "agreement": 0.81,
    "waste_heat": 0.65
  },
  "alerts": ["low_rhythm_stability", "collapse_risk"],
  "signals": {
    "pairwise_sim_mean": 0.86,
    "token_var_p95": 0.22,
    "agreement_rate": 0.79,
    "whr": 2.1
  },
  "context": {"model": "your-backend", "latency_ms": 420},
  "version": "0.2.0"
}</code></pre>
    <button class="copy-btn" data-copy="#schema">copy</button>
  </section>

  <!-- scoring and thresholds -->
  <section class="card" id="scoring">
    <h2>score and thresholds</h2>
    <p>
      the monitor fuses component metrics into a single coherence field score using a simple weighted average. start with the defaults. tune weights on your validation data.
    </p>

    <table class="table">
      <thead><tr><th>band</th><th>score</th><th>what to do</th></tr></thead>
      <tbody>
        <tr><td><span class="ok">good</span></td><td>0.75 to 1.00</td><td>allow fast path</td></tr>
        <tr><td><span class="warn">watch</span></td><td>0.50 to 0.74</td><td>add self check or slower decode</td></tr>
        <tr><td><span class="err">hold</span></td><td>below 0.50</td><td>route to human or fetch more constraints</td></tr>
      </tbody>
    </table>

<pre id="weights" aria-label="python weights"><code>from coherence_monitor import Weights
weights = Weights(consistency=.35, rhythm=.25, agreement=.25, waste_heat=.15)
mon = Monitor(model, thresholds=default_thresholds(), weights=weights)
</code></pre>
    <button class="copy-btn" data-copy="#weights">copy</button>

    <p class="muted">
      the coherence score is an internal stability signal, not a truth or safety score. 1.0 means the system is behaving like itself under compression. 0.0 means the coherence field is collapsing here. pair the score with task level evals, safety layers, and domain constraints.
    </p>

    <p class="muted small">
      composite alerts like <code>"collapse_risk"</code> fire when multiple components drop at once, for example low consistency plus high waste heat, or rhythm spikes plus ensemble disagreement.
    </p>
  </section>

  <!-- example integration -->
  <section class="card" id="example">
    <h2>example integration</h2>
<pre id="example-code"><code>def generate_safe(prompt: str) -> str:
    r = mon.run(prompt)
    if r.score &lt; 0.5 or "collapse_risk" in r.alerts:
        return slow_path_with_grounding(prompt)
    return fast_path(prompt)
</code></pre>
    <button class="copy-btn" data-copy="#example-code">copy</button>
  </section>

  <!-- dashboards -->
  <section class="card" id="dashboards">
    <h2>dashboards</h2>
    <p>
      emit results as json lines. ship to your logger and plot. this is enough for audits and for catching slow coherence drift over time.
    </p>
<pre id="emit"><code>r = mon.run(prompt)
with open("coherence_events.jsonl", "a") as f:
    f.write(r.to_json() + "\n")
</code></pre>
    <button class="copy-btn" data-copy="#emit">copy</button>
  </section>

  <!-- faq -->
  <section class="card" id="faq">
    <h2>faq</h2>

    <p><strong>does this require training access</strong><br>
    no. it works at inference. logits, text, and timing are enough.</p>

    <p><strong>is the score calibrated</strong><br>
    start with the defaults. then calibrate bands using your validation percentiles, per domain and per flow.</p>

    <p><strong>will this slow my system</strong><br>
    paraphrases and small ensembles add cost. you can run the full watch band only on high risk flows and keep a cheaper subset on everything else.</p>

    <p><strong>does a high coherence score mean the answer is correct</strong><br>
    no. the score reads stability under compression and perturbation. you still need task level evals, safety rules, and domain checks for correctness and risk.</p>

    <p><strong>how is this different from generic evals</strong><br>
    generic evals score outputs against labels. the coherence field monitor scores how the system behaves when you compress, paraphrase, and perturb it. it is a control layer that can sit next to any eval suite.</p>
  </section>

  <!-- refs -->
  <section class="card" id="references">
    <h2>references</h2>
    <ul>
      <li>joseph, m. (2025). compression-aware intelligence: coherence field monitor (v0.2.0).</li>
      <li>shannon, c. (1948). a mathematical theory of communication.</li>
      <li>tishby, n. (1999). the information bottleneck method.</li>
    </ul>
  </section>

  <section class="card" aria-live="polite">
    <p><small>last updated: <time id="last-updated"></time></small></p>
  </section>
</main>

<footer class="site-footer wrap">
  <small>© <span id="year"></span> Compression-Aware Intelligence. All concepts and terminology by Michele Joseph.</small>
</footer>

<script>
  // dates
  const y = document.getElementById('year');
  if (y) y.textContent = new Date().getFullYear();
  const lu = document.getElementById('last-updated');
  if (lu) lu.textContent = new Date().toISOString().slice(0, 10);

  // copy helpers
  document.querySelectorAll('.copy-btn').forEach(btn => {
    btn.addEventListener('click', () => {
      const target = document.querySelector(btn.dataset.copy);
      if (!target) return;
      const text = target.innerText;
      navigator.clipboard.writeText(text).then(() => {
        const old = btn.textContent;
        btn.textContent = 'copied';
        setTimeout(() => btn.textContent = old, 1200);
      });
    });
  });
</script>
</body>
</html>
